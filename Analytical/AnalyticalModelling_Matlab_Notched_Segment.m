clear; clc; close all;%%First approach "easy" F/A (simple stress model)F = 4000;%N  Total tensile forcet = 8;   %mm Thickness of the materialw0 = 25; %mm Max width of specimen and figures k = 24;  %mm Max cored length for the circle notch and height of figuresR = 15;  %mm Radius of the notchw1 = 6;  %mm The high of the notchw2 = 13; %mm The center widthh = @(l) R-sqrt(R^2.-(l.^2)./4); %Sagittal in a Circular segmentb = @(y) w2+h(abs(y)*2)*2;       %The width of the segment at that heightA = @(y) b(y).*t;                %Area of a segmentsigma = @(y) F./A(y);            %stress of that segmentResolution = 100;                %The resolution of the simple plotX = linspace(-k/2,k/2,Resolution);Y = linspace(-w0/2,w0/2,Resolution);[xCoordinate,yCoordinate] = meshgrid(X,Y);M = zeros(Resolution);for j = 1:Resolution             %a for loop running over all Y coordinates    xCoordinate(j,:) = linspace(h(abs(Y(j))*2)+w2/2,...    w1-h(abs(Y(j))*2)-w0/2,Resolution);     %Deriving the x coordinates for the y in the loop between the two edges    M(j,:) = sigma(Y(j)); %Calculate the stresses for that y coordinateendmax(M,[],"all") %Displays the max stressdisp("done with first method")%% Second methodResolution = 50;%C and Eta_0 and Eta1 are constants that determine the geometry %of the hyperbolic curve.Eta0 = (pi/2-0.6);Eta1 = (pi/2+0.6);Eta2 = (pi/2-0.6+pi);Eta3 = (pi/2+0.6+pi); %calculate all the eta's for the boundaryc = w2./(2*cosh(i*Eta0)) Eta_Top = linspace(double(Eta1), double(Eta0), Resolution);   %All eta values for the top of the modelEta_Bottom = linspace(double(Eta3), double(Eta2), Resolution);%All eta values for the bottom of the modelEta_all = [Eta_Top Eta_Bottom]; %Collects so it ranges from Eta0 to Eta1 jumps  to and %ranges from Eta2 to Eta3Xi = linspace(1.2, 0, Resolution); %the Xi values[Eta_mesh, Xi_mesh] = meshgrid(Eta_all, Xi); %Makes a mesh of the eta and xiTempzeta = Xi_mesh + Eta_mesh * i;                    %Her the code changes the order of the values so that instead of %Xi from going from 1.2 to 0 jumps to 1.2 and going to 0%Xi now goes from 1.2 to 0 jump to 0 and go to 1.2.zetaValues = zeros(Resolution*2,Resolution);          zetaValues(1:Resolution,:) = Tempzeta(:,1:Resolution);zetaValues(Resolution+1:end,:) = flipud(Tempzeta(:,Resolution+1:end));z = c * cosh(zetaValues);%calculates the cartesian coordinates from zeta  xValues = real(z); %and splits them op in x and yyValues = imag(z);disp("done with seting op mesh")%% Vector for vector plot for Eta and XiVcResolution = 9; %resolutionVcEta = [linspace(double(Eta0-(0.66*2)/(VcResolution)),...    double(Eta1),VcResolution+1) linspace(...    double((Eta2-(0.66*2)/(VcResolution))),double(Eta3),VcResolution+1)];%Creates a grid one layer larger than the resolution so that the difference %(between points) can be used for showing the direction (of vectors). %Therefore, Eta starts further to the right in both the upper and lower ranges.VcXi = linspace(0,1.2,VcResolution+1); [VcEta,VcXi]= meshgrid(VcEta,VcXi);VczetaValues = VcXi+VcEta.*i;Vcz = c*cosh(VczetaValues);        VcxValues = real(Vcz);VcyValues = imag(Vcz);TempUXi = VcxValues(2:end,:)-VcxValues(1:end-1,:);TempVXi = VcyValues(2:end,:)-VcyValues(1:end-1,:);%for showing the vector we need 4 data points its starting point at its%change so that will be VcxValues VcyValues for the start point and UXi and%Vxi for the direction of the arrow for eta its UEta and VEtaUXi = zeros(VcResolution,VcResolution*2);VXi = zeros(VcResolution,VcResolution*2);UXi(1:end,1:VcResolution) = TempUXi(1:end,2:VcResolution+1);VXi(1:end,1:VcResolution) = TempVXi(1:end,2:VcResolution+1);UXi(1:end,VcResolution+1:end) = TempUXi(1:end,VcResolution+3:end);VXi(1:end,VcResolution+1:end) = TempVXi(1:end,VcResolution+3:end);%This part is to cut out the part from the eta1 edge to the eta2 edgeTempUEta = VcxValues(:,1:end-1)-VcxValues(:,2:end);TempVEta = VcyValues(:,1:end-1)-VcyValues(:,2:end);UEta = zeros(VcResolution,VcResolution*2);VEta = zeros(VcResolution,VcResolution*2);UEta(1:end,1:VcResolution) = TempUEta(1:end-1,1:VcResolution);VEta(1:end,1:VcResolution) = TempVEta(1:end-1,1:VcResolution);UEta(1:end,VcResolution+1:end) = TempUEta(1:end-1,VcResolution+2:end);VEta(1:end,VcResolution+1:end) = TempVEta(1:end-1,VcResolution+2:end);%And the same is repeated for EtaVcxValues = VcxValues(2:end,[2:VcResolution+1 VcResolution+3:end]);VcyValues = VcyValues(2:end,[2:VcResolution+1 VcResolution+3:end]);%This part is to cut out the part from the eta1 edge to the eta2 edge and%the beginningdisp("done with vektor")%% Stress functionFy = F/t;                                       %The theory in timoshenko is best on forces per thicknessA = double(-Fy/(pi-2.*Eta0+sin(2.*Eta0)));      %The A variable derived from the equation om page 206 "Fy=-A(pi...."B = -A.*cos(Eta0).^2;                           %equation e page 205alpha = @(zeta) sinh(zeta)./sinh(conj(zeta));          %equation (b) page 197 "e^2iaplha" is just called alpha%Phi1 and Chi1 are eq. (b) page 205%psi1 = @(zeta) -(i.*A)./(2.*c.*sinh(zeta));psi1 = @(zeta) -(i.*A)./(2.*sqrt(cosh(zeta)-1).*sqrt(cosh(zeta)+1).*c);chi1 = @(zeta) -1./2.*A.*i.*zeta-(1./2.*A+B).*i.*coth(zeta); %Phi2 and Chi2 are Derivative in Mapel %psi2 = @(zeta) (A.*i.*cosh(zeta)./(c.^2.*2.*sinh(zeta).^3)); psi2 = @(zeta) (A.*i*cosh(zeta))./(c.^2.*sqrt(cosh(zeta)-1).*sqrt(cosh(zeta)+1).*(cosh(2.*zeta)-1));chi2 = @(zeta) i.*(A.*cosh(2.*zeta)-3*A-4*B)./(4.*c.*(cosh(zeta)-1).^(3/2).*(cosh(zeta)+1).^(3/2));%chi2 = @(zeta)  1i.*((4.*A.*cosh(zeta./2).^4-4.*A.*cosh(zeta./2).^2 ...%    -A-2.*B).*sech(zeta./2).^3.*csch(zeta./2).^3)./(16.*c);%From Timashenko eq. 109 & 110 p. 197sigma_Xi = @(zeta)  2.*real(psi1(zeta))...    +real(alpha(zeta).*(conj(c.*cosh(zeta)).*psi2(zeta)+chi2(zeta)));%sigma_Eta = @(zeta) 2.*real(psi1(zeta))...    -real(alpha(zeta).*(conj(c.*cosh(zeta)).*psi2(zeta)+chi2(zeta)));%tau_XiEta = @(zeta) imag(alpha(zeta).*conj(c.*cosh(zeta)).*psi2(zeta)...    +chi2(zeta)); %Page 197 equations 109,110%Evaluate the functions to get the stressesstressValues_Xi = sigma_Xi(zetaValues);stressValues_Eta = sigma_Eta(zetaValues);stressValues_XiEta = tau_XiEta(zetaValues);%stressValues_Xi(ceil(end/2)+2:end,:) = -stressValues_Xi(ceil(end/2)+2:end,:);%stressValues_Eta(ceil(end/2)+2:end,:) = -stressValues_Eta(ceil(end/2)+2:end,:);%stressValues_XiEta(ceil(end/2)+2:end,:) = -stressValues_XiEta(ceil(end/2)+2:end,:);stressValues_FirstPrincipal = (stressValues_Xi+stressValues_Eta)./2+...    sqrt(((stressValues_Xi-stressValues_Eta)./2).^2+stressValues_XiEta.^2);stressValues_SecondPrincipal =(stressValues_Xi+stressValues_Eta)./2-...    sqrt(((stressValues_Xi-stressValues_Eta)./2).^2+stressValues_XiEta.^2);stressValues_Von = sqrt(stressValues_FirstPrincipal.^2+...    stressValues_SecondPrincipal.^2-...    stressValues_FirstPrincipal.*stressValues_SecondPrincipal);logAlpha = log(alpha(zetaValues))/2;angleValuesCos = cos(real(logAlpha)+imag(logAlpha));angleValuesSin = sin(real(logAlpha)+imag(logAlpha));stressValues_X = stressValues_Xi.*angleValuesCos.^2 + stressValues_Eta.*angleValuesSin.^2 + 2.*stressValues_XiEta.*angleValuesSin.*angleValuesCos;stressValues_Y = stressValues_Xi.*angleValuesSin.^2 + stressValues_Eta.*angleValuesCos.^2 - 2.*stressValues_XiEta.*angleValuesSin.*angleValuesCos;stressValues_XY = ((stressValues_Xi-stressValues_Eta).*angleValuesSin.*angleValuesCos + stressValues_XiEta.*(angleValuesCos.^2-angleValuesSin.^2));%% Finds coordinates for max value in equivalent stress field % Max Von Mises stress and its position[SigMax, iMax] = max(stressValues_Von(:));                % max value + linear index[rowMax, colMax] = ind2sub(size(stressValues_Von), iMax); % convert to row/columnxMax = xValues(rowMax, colMax);                           % x-coordinate of maxyMax = yValues(rowMax, colMax);                           % y-coordinate of max%% Calculates the percentage differences in CrossSection-Area%And in the area under the stress curvemax(stressValues_FirstPrincipal,[],'all')max(stressValues_SecondPrincipal,[],'all')max(stressValues_Von,[],'all')N = M;N(isnan(M)) = 0;StressAreaSimpel = w2*N(end/2,end/2);StressAreaComplex = trapz(xValues(end/2,:), stressValues_Von(end/2,:));StressAreaRatio = (StressAreaComplex-StressAreaSimpel)./StressAreaSimpel;CrossSectionArealRatio = (w2-max(xValues(end/2,:))*2)/w2;fprintf("StressAreaRatio: %.4f\n", StressAreaRatio)fprintf("CrossSectionArealRatio: %.4f\n", CrossSectionArealRatio)disp("done with stress funktions")%% Define colormap for sigma_xi plot%This is don to better show the contureplots where they go from max plus to%max minus and therefor this is just "jet" shiftet away from 0 to show thatN = 256*0.7;nMid = round(0.60*N);cm = colormap("jet");negPart = cm(30:127,:);midPart = repmat([0.5 1 0.5], nMid, 1);posPart = cm(129:226,:);cmap = [negPart; midPart; posPart];set(gcf, 'Visible', 'off');%% Plot the stress distributionfigure('Color','w')colormap("jet")set(gca, 'FontName', 'CMU Serif')contourf(xCoordinate,yCoordinate,M,100,"LineStyle","none")c = colorbar("AxisLocation","out");c.Label.String = "[MPa]";c.Ticks = [21 25 29 33 37];box off;set(gcf,'Name',"simpel model")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 1. figur")figure('Color','w')%colormap(cmap)colormap("jet")hold oncontourf(xValues,yValues,stressValues_Y,100,"LineStyle","none")%quiver(VcxValues,VcyValues,UXi,VXi,0.4,"Color",[0 0 0])hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"sigma Y")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 2. figur")figure('Color','w')%colormap(cmap)colormap("jet")hold oncontourf(xValues,yValues,stressValues_X,100,"LineStyle","none")%quiver(VcxValues,VcyValues,UXi,VXi,0.4,"Color",[0 0 0])hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"sigma X")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 3. figur")figure('Color','w')%colormap(cmap)colormap("jet")hold oncontourf(xValues,yValues,stressValues_Xi,100,"LineStyle","none")%quiver(VcxValues,VcyValues,UXi,VXi,0.4,"Color",[0 0 0])hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"sigma_xi")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 4. figur")figure('Color','w')%colormap(cmap)colormap("jet")hold oncontourf(xValues,yValues,stressValues_Eta,100,"LineStyle","none")%quiver(VcxValues,VcyValues,UEta,VEta,0.4,"Color",[0 0 0])hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"sigma_Eta")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 5. figur")figure('Color','w')%colormap(cmap)colormap("jet")hold oncontourf(xValues,yValues,stressValues_FirstPrincipal,100,"LineStyle","none")hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"sigma_FirstPrincipal")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 6. figur")figure('Color','w')%colormap(cmap)colormap("jet")hold oncontourf(xValues,yValues,stressValues_SecondPrincipal,100,"LineStyle","none")hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"sigma_SecondPrincipal")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 7. figur")figure('Color','w')colormap("jet")hold oncontourf(xValues,yValues,stressValues_XiEta,100,"LineStyle","none")%quiver(VcxValues,VcyValues,UXi,VXi,0.2,"Color",[0 0 0])%quiver(VcxValues,VcyValues,UEta,VEta,0.2,"Color",[0 0 0])hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"tau_xieta")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 8. figur")figure('Color','w')colormap("jet")hold oncontourf(xValues,yValues,stressValues_XY,100,"LineStyle","none")%quiver(VcxValues,VcyValues,UXi,VXi,0.2,"Color",[0 0 0])%quiver(VcxValues,VcyValues,UEta,VEta,0.2,"Color",[0 0 0])hold offc = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"tau_XY")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 9. figur")figure('Color','w')colormap("jet")hold oncontourf(xValues,yValues,stressValues_Von,150,"LineStyle","none")dx = 0.15;plot(xMax, yMax, 'o', 'MarkerSize', 5, ...    'MarkerFaceColor','w','MarkerEdgeColor','k');text(xMax-dx, yMax, sprintf('  %.1f MPa', SigMax), ...    'HorizontalAlignment','right','VerticalAlignment','middle', ...    'Margin',2,'FontWeight','bold', ...    'Tag','peakLabel', ...    'FontSize',8);c = colorbar("AxisLocation","out");c.Label.String = "[MPa]";set(gcf,'Name',"sigma_von")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 10. figur")figure('Color','w')hold onplot(xValues(end/2,:),stressValues_Xi(end/2-1,:),Color='r',LineWidth=0.1)plot(xValues(end/2,:),stressValues_Eta(end/2-1,:),Color='b',LineWidth=0.1)plot(xValues(end/2,:),stressValues_XiEta(end/2-1,:),Color='g',LineWidth=0.1)plot(xValues(end/2,:),stressValues_Von(end/2-1,:),Color=[1 0 1],LineWidth=0.1)plot(xCoordinate(end/2,:),M(end/2,:),Color=[0 1 1],LineWidth=0.1)set(gcf,'Name',"force over displacement in the center")xlabel("{\it x} [mm]")ylabel("{\it y} [MPa]")legend("\sigma_\xi","\sigma_\eta","\tau_{\xi\eta}","\sigma_{eq}","Simpel model","Location","eastoutside")disp("done with 11. figur")M(~isnan(M)) = 1;figure('Color','w')colormap([1 0 0])hold oncontourf(xCoordinate,yCoordinate,M,1,"LineStyle","none")plot(xValues,yValues,"LineStyle","none",Marker="*",Color="b")set(gcf,'Name',"geometric difference")xlim([-w0/2 w0/2])ylim([-k/2 k/2])xlabel("{\it x} [mm]")ylabel("{\it y} [mm]")disp("done with 12. figur")%% Line for comparison plots% Start and end points are defined in cartesian coordinatesx_start = -6.5;    x_end = 6.5;y_start = 0.0;     y_end = 0.0;% Difference between start and end points dx = x_end-x_start;dy = y_end-y_start;% Line parameter to make N points along the lineN = 200;t = linspace(0,1,N);% Calculate the stress values along the defined linex_line = x_start + t * dx;y_line = y_start + t * dy;% Calculate distance along lines_line = sqrt(dx^2+dy^2)*t;% Interpolation between all points.F_sig_x = scatteredInterpolant(xValues(:), yValues(:), stressValues_X(:), 'linear', 'none');F_sig_y = scatteredInterpolant(xValues(:), yValues(:), stressValues_Y(:), 'linear', 'none');F_tau_xy = scatteredInterpolant(xValues(:), yValues(:), stressValues_XY(:), 'linear', 'none');% Stresses on the line are calculatedsigma_x_line = F_sig_x(x_line,y_line);sigma_y_line = F_sig_y(x_line,y_line);tau_xy_line = F_tau_xy(x_line,y_line);% Compile data and exportStress_lines = { ...    sigma_x_line, ...    sigma_y_line, ...    tau_xy_line ...    };names = {'sigma_x','sigma_y','tau_xy'};outDir = 'Lineout_data';for k = 1:numel(Stress_lines)        T{k} = table(s_line(:), Stress_lines{k}(:), 'VariableNames', {'Length_mm', names{k}});    filename = sprintf('Notch_Hyperbolic_%s.csv', names{k});    filepath = fullfile(outDir, filename);        writetable(T{k}, filepath);    fprintf('Saved lineout data as: %s\n', filepath);end